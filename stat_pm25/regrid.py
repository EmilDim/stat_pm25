""" Re-gridding utilities and helper functions. """

import pyresample

import numpy as np
import xarray as xr

from darpy import copy_attrs, append_history


def _try_open(f):
    """ Try to open 'f' as a Dataset if it's a string; else
    let it pass through. """
    if isinstance(f, str):
        f = xr.open_dataset(f)
    return f


def remap_dataset(src_data, target_data, weights):
    """ Re-map a source dataset to the horizontal grid of the given
    target dataset.

    The source dataset should be a Dataset; it can have multiple fields
    and multiple dimensions although we assume the horizontal grid is
    defined by 'lat' and 'lon'. The target data only needs to have
    'lat' and 'lon' coordinates. The weights provided here should be
    the SCRIP-format weights generated by CDO, read in as a Dataset.

    For example, you can generate conservative weights by executing

        $ cdo griddes my_target_data.nc > tgt.grid
        $ cdo remapycon,tgt.grid my_source_data weights.nc

    Then you would read in `weights.nc` via xarray.

    .. note::

        We've assumed "fracarea" normalization here. If destarea or
        no normalization is used when generating weights via CDO, then
        you will need to adapt the re-gridding math from the SCRIP
        documentation to handle this.

    """

    src_data = _try_open(src_data)
    target_data = _try_open(target_data)
    weights = _try_open(weights)

    snlon, snlat = len(src_data.lon), len(src_data.lat)
    tnlon, tnlat = len(target_data.lon), len(target_data.lat)

    # Stack the source data so that we ravel the latitude-longitude
    # dimensions
    stacked_src_data = src_data.stack(cell=['lat', 'lon'])

    # Prepare the SCRIP weights and arrays
    remap_matrix = weights.remap_matrix.values
    src_address = weights.src_address.values - 1
    dst_address = weights.dst_address.values - 1
    num_links = len(src_address)
    n_cells_dst = len(weights.dst_grid_center_lat)

    new_data = {}
    for field in src_data.data_vars:
        da = stacked_src_data[field]
        arr = da.values
        leading_shape, n_cells_src = arr.shape[:-1], arr.shape[-1]

        dst_array = np.empty(list(leading_shape) + [n_cells_dst, ])
        for n in range(num_links):

            dst_addr, src_addr = dst_address[n], src_address[n]
            dst_array[..., dst_addr] += (remap_matrix[n]*arr[..., src_addr])#/(dst_area[dst_addr]*dst_frac[dst_addr])

        new_data[field] = (da.dims, dst_array)

    # Re-package the re-gridded data
    template = target_data[['lat', 'lon']].copy()
    template = template.stack(cell=['lat', 'lon'])
    for c in stacked_src_data.coords:
        if c == 'cell': continue
        new_data[c] = stacked_src_data[c]
    output = template.update(new_data)

    # Un-ravel lat/lon dims
    output = output.unstack('cell')

    # Copy attributes
    output = copy_attrs(src_data, output)
    output = append_history(
        output,
        "remap_dataset - mapped from {}x{} -> {}x{})"
        .format(snlat, snlon, tnlat, tnlon),
        extra_info=weights.attrs['map_method']
    )

    return output


def model_to_obs_grid(model_data, obs_def, mod_def, coords={}):
    """ Resample data from a model to the obs grid. """


    data_model_rs = xr.Dataset(coords=coords)

    resample_to_obs = lambda data2d: pyresample.kd_tree.resample_nearest(
        mod_def, data2d, obs_def, radius_of_influence=500000, fill_value=None
    )

    for field in model_data.data_vars:
        print(field)
        da = model_data[field]
        da_rs = np.asarray([
            resample_to_obs(da.sel(time=t).values) for t in da.time
        ])
        print(da_rs.shape)
        data_model_rs[field] = (['time', 'lat', 'lon'], da_rs)

    return data_model_rs